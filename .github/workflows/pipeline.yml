name: Deploy Workflow
on: deployment
jobs:
  deploy-ENVIRONMENT_NAME:
    name: Deploy to ENVIRONMENT_NAME environment
    if: ${{ github.event.deployment.environment }} == ENVIRONMENT_NAME
    concurrency: ENVIRONMENT_NAME
    permissions:
      deployments: write
      contents: read
      id-token: write # Aggiunto: Necessario per l'autenticazione OIDC
    runs-on: ubuntu-latest
    container: miaplatform/mlp:2.1.0
    steps:
      - uses: actions/checkout@v4

      # --- Aggiunto: Autenticazione con AWS tramite OIDC ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # SOSTITUISCI con l'ARN del Ruolo IAM che hai creato per GitHub Actions
          role-to-assume: arn:aws:iam::905418444414:role/github-actions-secrets-manager-role
          # SOSTITUISCI con la tua Regione AWS
          aws-region: eu-west-1 

      # --- Aggiunto: Recupero dei Secrets da AWS Secrets Manager ---
      - name: Retrieve Secrets from AWS Secrets Manager
        id: secrets_manager # Assegna un ID per accedere agli output
        uses: aws-actions/aws-secretsmanager-get-secrets@v1
        with:
          # Inserisci gli ID dei tuoi secret, separati da spazi o newline.
          # Imposta 'parse-json-secrets: true' se i tuoi secret sono JSON, altrimenti puoi ometterlo.
          # Se i secrets sono JSON, l'Action creerÃ  variabili d'ambiente come SECRET_ID_KEYNAME.
          secret-ids: |
            mongodb/credentials
          parse-json-secrets: true 

      - name: Update deployment status (pending)
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'pending'
          deployment-id: ${{ github.event.deployment.id }}
          
      - name: Deploy my app
        env:
          GIT_DEPTH: 1
          ENVIRONMENT_VARIABLES_PREFIX: MIA_
          BASE_PATH: ${{ github.workspace }}/configuration
          OVERLAY_PATH: "${{ github.workspace }}/overlays/${{ github.event.deployment.environment }}"
          DESTINATION_PATH: "${{ github.workspace }}/interpolated-files"
          GENERATE_FILE: "${{ github.workspace }}/mlp.yaml"
          VARIABLES_FILE: "${{ github.workspace }}/overlays/${{ github.event.deployment.environment }}/variables.env"
          ENVIRONMENT_TO_DEPLOY: ${{ github.event.deployment.environment }}
          ENVIRONMENT_PREFIX: ${{ github.event.deployment.environment }}_
          DEPLOY_TYPE: ${{ github.event.deployment.payload.variables.DEPLOY_TYPE }}
          FORCE_DEPLOY_WHEN_NO_SEMVER: ${{ github.event.deployment.payload.variables.FORCE_DEPLOY_WHEN_NO_SEMVER }}
          KUBE_NAMESPACE: ${{ github.event.deployment.payload.variables.KUBE_NAMESPACE }}
          
          # --- Aggiornato: Uso dei valori da Secrets Manager ---
          # Assumendo che il secret 'kubernetes/credentials' contenga le chiavi 'KUBE_URL', 'KUBE_CA_PEM', 'KUBE_TOKEN'
          KUBE_URL: ${{ env.KUBERNETES_CREDENTIALS_KUBE_URL }}
          KUBE_CA_PEM: ${{ env.KUBERNETES_CREDENTIALS_KUBE_CA_PEM }}
          KUBE_TOKEN: ${{ env.KUBERNETES_CREDENTIALS_KUBE_TOKEN }}
          
          # Assumendo che il secret 'nexus/credentials' contenga le chiavi 'USER', 'TOKEN', 'URL'
          NEXUS_USER: ${{ env.NEXUS_CREDENTIALS_USER }}
          NEXUS_TOKEN: ${{ env.NEXUS_CREDENTIALS_TOKEN }}
          NEXUS_URL: ${{ env.NEXUS_CREDENTIALS_URL }}
          
          # Assumendo che il secret 'kafka/credentials' contenga le chiavi 'BROKERS', 'SASL_PASSWORD', 'SASL_USERNAME'
          KAFKA_BROKERS: ${{ env.KAFKA_CREDENTIALS_BROKERS }}
          KAFKA_SASL_PASSWORD: ${{ env.KAFKA_CREDENTIALS_SASL_PASSWORD }}
          KAFKA_SASL_USERNAME: ${{ env.KAFKA_CREDENTIALS_SASL_USERNAME }}
          # ---------------------------------------------------
          MONGODB_URL: ${{ env.MONGODB_CREDENTIALS_MONGODB_URL }}
          
        run: |
          # Il tuo script RUN resta invariato, dato che i secrets sono ora variabili d'ambiente
          echo "${MONGODB_URL}"
          export RELEASE_DATE="$(date -I'seconds' -u)"
          tee /tmp/ca.pem > /dev/null << EOF
          ${KUBE_CA_PEM}
          EOF
          mkdir ${DESTINATION_PATH}
          test -f "${VARIABLES_FILE}" && set -a && source "${VARIABLES_FILE}"
          test -f "${GENERATE_FILE}" && mlp generate -c "${GENERATE_FILE}" -e "${ENVIRONMENT_PREFIX}" -e "${ENVIRONMENT_VARIABLES_PREFIX}" -o "${OVERLAY_PATH}"
          mlp hydrate "${BASE_PATH}" "${OVERLAY_PATH}"
          mlp interpolate -e "${ENVIRONMENT_PREFIX}" -e "${ENVIRONMENT_VARIABLES_PREFIX}" -f "${BASE_PATH}" -o "${BASE_PATH}"
          mlp interpolate -e "${ENVIRONMENT_PREFIX}" -e "${ENVIRONMENT_VARIABLES_PREFIX}" -f "${OVERLAY_PATH}" -o "${OVERLAY_PATH}"
          mlp kustomize "${OVERLAY_PATH}" -o "${DESTINATION_PATH}/kustomize-output.yaml"
          mlp deploy --ensure-namespace=false --server "${KUBE_URL}" --certificate-authority "/tmp/ca.pem" --token "${KUBE_TOKEN}" --deploy-type "${DEPLOY_TYPE}" --force-deploy-when-no-semver="${FORCE_DEPLOY_WHEN_NO_SEMVER}" -f "${DESTINATION_PATH}/kustomize-output.yaml" -n "${KUBE_NAMESPACE}"
          
      - name: Update deployment status (success)
        if: success()
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'success'
          deployment-id: ${{ github.event.deployment.id }}
          
      - name: Update deployment status (failure)
        if: failure()
        uses: chrnorm/deployment-status@v2
        with:
          token: '${{ github.token }}'
          state: 'failure'
          deployment-id: ${{ github.event.deployment.id }}